<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§Ù„Ù…ÙØ³Ù…ÙÙ‘Ø¹ Ø§Ù„Ø°ÙƒÙŠ AI | Ultra Immersive</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;600;900&display=swap');

        :root {
            --primary: #c084fc;
            --accent: #f472b6;
            --success: #2dd4bf;
            --error: #fb7185;
            --bg: #020617;
            --glass: rgba(15, 23, 42, 0.7);
        }

        body {
            margin: 0; padding: 0;
            background: var(--bg);
            color: white;
            font-family: 'Cairo', sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Ø®Ù„ÙÙŠØ© Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠØ© Ù…ØªØ­Ø±ÙƒØ© */
        .vfx-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, #1e1b4b 0%, #020617 100%);
            z-index: -1;
        }

        .orb {
            position: absolute; width: 600px; height: 600px;
            background: radial-gradient(circle, rgba(192, 132, 252, 0.1) 0%, transparent 70%);
            border-radius: 50%; animation: move 20s infinite alternate;
        }

        @keyframes move { from { transform: translate(-20%, -20%); } to { transform: translate(20%, 20%); } }

        .container {
            width: 95%; max-width: 1000px;
            z-index: 10;
        }

        /* Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰: Ø§Ù„Ù…Ø­Ø±Ø± Ø§Ù„Ø¯Ù‚ÙŠÙ‚ */
        .setup-card {
            background: var(--glass);
            backdrop-filter: blur(30px);
            padding: 50px;
            border-radius: 40px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 40px 100px rgba(0,0,0,0.6);
            transition: 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }

        h1 {
            font-size: 3rem; font-weight: 900; margin-bottom: 10px;
            background: linear-gradient(to bottom right, #fff, var(--primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        textarea {
            width: 100%; height: 250px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 25px; color: #e2e8f0;
            padding: 25px; font-size: 1.4rem; line-height: 1.6;
            outline: none; transition: 0.3s; box-sizing: border-box;
            font-family: 'Cairo', sans-serif;
        }
        textarea:focus { border-color: var(--primary); box-shadow: 0 0 30px rgba(192, 132, 252, 0.2); }

        /* Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©: ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªÙ„Ø§ÙˆØ© Ø§Ù„ØºØ§Ù…Ø±Ø© */
        .practice-card {
            display: none; width: 100%; text-align: center;
            animation: fadeIn 1s ease;
        }

        .stats-hud {
            display: flex; justify-content: center; gap: 50px; margin-bottom: 40px;
            font-size: 1.2rem; font-weight: 600; text-transform: uppercase;
            letter-spacing: 2px;
        }

        .word-display {
            font-size: 4rem; /* Ø­Ø¬Ù… ÙØ®Ù… Ø¬Ø¯Ø§Ù‹ */
            font-weight: 900; line-height: 1.4;
            display: flex; flex-wrap: wrap; justify-content: center;
            gap: 20px; min-height: 300px; padding: 20px;
        }

        .w-ai {
            opacity: 0.05; filter: blur(15px);
            transform: scale(0.8); transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .w-ai.active {
            opacity: 1; filter: blur(0); transform: scale(1.1);
            color: white; text-shadow: 0 0 40px var(--primary);
        }

        .w-ai.error {
            opacity: 0.5; filter: blur(0); color: var(--error);
            border-bottom: 4px solid var(--error); transform: scale(0.9);
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªØ·ÙˆØ±Ø© */
        .controls-ai {
            margin-top: 50px; display: flex; flex-direction: column; align-items: center;
        }

        .mic-master {
            width: 100px; height: 100px; border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border: none; color: white; font-size: 2.5rem;
            cursor: pointer; position: relative; transition: 0.4s;
            box-shadow: 0 15px 40px rgba(192, 132, 252, 0.4);
        }

        .mic-master.recording {
            animation: pulse-ring 1.5s infinite;
            background: var(--error);
        }

        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(251, 113, 133, 0.7); }
            70% { box-shadow: 0 0 0 35px rgba(251, 113, 133, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 113, 133, 0); }
        }

        .btn-ready {
            margin-top: 30px; background: white; color: black;
            padding: 18px 50px; border-radius: 50px; font-weight: 900;
            border: none; cursor: pointer; font-size: 1.2rem;
            transition: 0.3s;
        }
        .btn-ready:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(255,255,255,0.2); }

        .hidden { display: none !important; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div class="vfx-bg"></div>
    <div class="orb"></div>

    <div class="container">
        <div id="phase1" class="setup-card">
            <h1>Ø§Ù„Ù…ÙØ³Ù…ÙÙ‘Ø¹ Ø§Ù„Ø°ÙƒÙŠ <small style="font-size: 0.9rem; opacity: 0.5;">ULTRA AI</small></h1>
            <p style="color: #94a3b8; font-size: 1.1rem; margin-bottom: 30px;">Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¹Ø±Ù Ø§Ù„Ù„Ø­Ø¸ÙŠ Ø§Ù„Ù…ØªØ·ÙˆØ± Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ØªÙ„Ø§ÙˆØ© ÙˆØ§Ù„Ø­ÙØ¸.</p>
            
            <textarea id="sourceText" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„ØµÙˆØªÙŠ Ù„Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø³Ø±ÙŠØ¹..."></textarea>
            
            <div style="display: flex; gap: 20px; margin-top: 30px;">
                <button class="btn-ready" style="background: rgba(255,255,255,0.05); color: white; border: 1px solid rgba(255,255,255,0.1);" onclick="startDictation()" id="dictBtn">ğŸ™ï¸ Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„Ù†Øµ</button>
                <button class="btn-ready" onclick="goToPractice()">Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ù…ÙŠØ¹ Ø§Ù„Ø­ÙŠ âš¡</button>
            </div>
        </div>

        <div id="phase2" class="practice-card">
            <div class="stats-hud">
                <div style="color: var(--success)">Ø§Ù„Ø¯Ù‚Ø©: <span id="accVal">100</span>%</div>
                <div style="color: var(--error)">Ø§Ù„Ø¹Ø«Ø±Ø§Øª: <span id="errVal">0</span></div>
            </div>

            <div id="wordDisplay" class="word-display"></div>

            <div class="controls-ai">
                <button id="mainMic" class="mic-master" onclick="togglePracticeMic()">ğŸ¤</button>
                <p id="statusTxt" style="margin-top: 20px; color: #64748b; font-weight: 600;">Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªÙ…Ø§Ø¹.. Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªÙ„Ø§ÙˆØ©</p>
                
                <button onclick="location.reload()" style="background: none; border: none; color: #475569; cursor: pointer; margin-top: 30px; font-weight: bold;">Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬Ù„Ø³Ø© â†º</button>
            </div>
        </div>
    </div>

    <script>
        let recognition = new (window.webkitSpeechRecognition || window.SpeechRecognition)();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'ar-SA';

        let originalWords = [];
        let currentIndex = 0;
        let errors = 0;
        let isActive = false;

        // Ø§Ù„ØµÙØ­Ø© 1: Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„Ù†Øµ
        function startDictation() {
            const btn = document.getElementById('dictBtn');
            if(!isActive) {
                recognition.onresult = (e) => {
                    document.getElementById('sourceText').value = Array.from(e.results).map(r => r[0].transcript).join('');
                };
                recognition.start();
                isActive = true;
                btn.innerText = "ğŸ›‘ ØªÙˆÙ‚Ù";
                btn.style.borderColor = "var(--error)";
            } else {
                recognition.stop();
                isActive = false;
                btn.innerText = "ğŸ™ï¸ Ø¥Ù…Ù„Ø§Ø¡ Ø§Ù„Ù†Øµ";
                btn.style.borderColor = "rgba(255,255,255,0.1)";
            }
        }

        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØµÙØ­Ø© 2
        function goToPractice() {
            const text = document.getElementById('sourceText').value.trim();
            if(!text) return alert("ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†Øµ Ø£ÙˆÙ„Ø§Ù‹");

            originalWords = text.split(/\s+/);
            const display = document.getElementById('wordDisplay');
            display.innerHTML = originalWords.map((w, i) => `<span class="w-ai" id="word-${i}">${w}</span>`).join('');

            document.getElementById('phase1').style.display = 'none';
            document.getElementById('phase2').style.display = 'block';
            if(isActive) recognition.stop();
            isActive = false;
        }

        // Ø§Ù„ØµÙØ­Ø© 2: Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ³Ù…ÙŠØ¹ Ø§Ù„Ù„Ø­Ø¸ÙŠ
        function togglePracticeMic() {
            const btn = document.getElementById('mainMic');
            if(!isActive) {
                recognition.onresult = (e) => {
                    const transcript = Array.from(e.results).map(r => r[0].transcript).join(' ').trim();
                    processSpeech(transcript);
                };
                recognition.start();
                isActive = true;
                btn.classList.add('recording');
                document.getElementById('statusTxt').innerText = "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ù„ØµÙˆØªÙƒ...";
            } else {
                recognition.stop();
                isActive = false;
                btn.classList.remove('recording');
            }
        }

        function processSpeech(transcript) {
            const spokenWords = transcript.split(/\s+/);
            const latestSpoken = spokenWords[spokenWords.length - 1];

            if(currentIndex < originalWords.length) {
                const target = originalWords[currentIndex];
                
                if(isSimilar(latestSpoken, target)) {
                    document.getElementById(`word-${currentIndex}`).className = 'w-ai active';
                    currentIndex++;
                    // ØªÙ…Ø±ÙŠØ± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ Ø·ÙˆÙŠÙ„Ø§Ù‹
                    document.getElementById(`word-${currentIndex-1}`).scrollIntoView({behavior: "smooth", block: "center"});
                } else if(spokenWords.length > currentIndex) {
                    // Ø¥Ø°Ø§ ÙˆÙ‚Ø¹ Ø®Ø·Ø£ØŒ ÙŠØªÙ… Ø§Ù„ØªÙ„Ù‚ÙŠÙ† Ø¢Ù„ÙŠØ§Ù‹ Ø¨Ø¹Ø¯ Ù…Ø­Ø§ÙˆÙ„Ø© ÙˆØ§Ø­Ø¯Ø© Ø®Ø§Ø·Ø¦Ø©
                    handleError();
                }
            }
            updateStats();
        }

        function handleError() {
            const el = document.getElementById(`word-${currentIndex}`);
            if(el && !el.classList.contains('active')) {
                el.className = 'w-ai error';
                errors++;
                currentIndex++; // ØªØ®Ø·ÙŠ Ù„Ù„ÙƒÙ„Ù…Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© (ØªÙ„Ù‚ÙŠÙ† Ø°ÙƒÙŠ)
                beep();
            }
        }

        function updateStats() {
            document.getElementById('errVal').innerText = errors;
            const acc = Math.max(0, 100 - (errors * 3));
            document.getElementById('accVal').innerText = Math.round(acc);
            if(currentIndex >= originalWords.length) {
                document.getElementById('statusTxt').innerText = "ØªÙ…Øª Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø§Ù‡Ø±! ğŸ‰";
                recognition.stop();
            }
        }

        function isSimilar(s1, s2) {
            const clean = s => s.replace(/[Ù‹ÙŒÙÙÙÙÙ‘Ù€]/g, "").replace(/[Ø£Ø¥Ø¢]/g, "Ø§").replace(/Ø©/g, "Ù‡").trim();
            return clean(s1) === clean(s2);
        }

        function beep() {
            const ctx = new AudioContext();
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = 'sine'; o.frequency.value = 140;
            g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.2);
            o.connect(g).connect(ctx.destination);
            o.start(); o.stop(ctx.currentTime + 0.2);
        }
    </script>
</body>
</html>
